/*
 * GLSLGenerator.cpp
 * 
 * This file is part of the XShaderCompiler project (Copyright (c) 2014-2017 by Lukas Hermanns)
 * See "LICENSE.txt" for license information.
 */

#include "GLSLGenerator.h"
#include "GLSLExtensionAgent.h"
#include "GLSLConverter.h"
#include "GLSLKeywords.h"
#include "GLSLIntrinsics.h"
#include "ReferenceAnalyzer.h"
#include "ControlPathAnalyzer.h"
#include "TypeDenoter.h"
#include "Exception.h"
#include "Helper.h"
#include <initializer_list>
#include <algorithm>
#include <cctype>
#include <set>


namespace Xsc
{


/*
 * Internal structures
 */

struct IfStmntArgs
{
    bool inHasElseParentNode;
};

struct StructDeclArgs
{
    bool inEndWithSemicolon;
    bool outStructWritten;
};


/*
 * GLSLGenerator class
 */

GLSLGenerator::GLSLGenerator(Log* log) :
    Generator{ log }
{
}

void GLSLGenerator::GenerateCodePrimary(
    Program& program, const ShaderInput& inputDesc, const ShaderOutput& outputDesc)
{
    /* Store parameters */
    versionOut_         = outputDesc.shaderVersion;
    nameManglingPrefix_ = outputDesc.nameManglingPrefix;
    allowExtensions_    = outputDesc.options.allowExtensions;
    explicitBinding_    = outputDesc.options.explicitBinding;
    preserveComments_   = outputDesc.options.preserveComments;
    allowLineMarks_     = outputDesc.formatting.lineMarks;
    compactWrappers_    = outputDesc.formatting.compactWrappers;
    alwaysBracedScopes_ = outputDesc.formatting.alwaysBracedScopes;
    for (const auto& s : outputDesc.options.vertexShaderInputSemanticMapping)
    {
        vertexShaderInputSemanticMapping_.insert(std::pair<CiString, int>(ToCiString(s.first), s.second));
    }

    if (program.entryPointRef)
    {
        try
        {
            /* Mark all reachable AST nodes */
            {
                ReferenceAnalyzer refAnalyzer;
                refAnalyzer.MarkReferencesFromEntryPoint(program, inputDesc.shaderTarget);
            }

            /* Mark all control paths */
            {
                ControlPathAnalyzer pathAnalyzer;
                pathAnalyzer.MarkControlPaths(program);
            }

            /* Convert AST for GLSL code generation */
            {
                GLSLConverter converter;
                converter.Convert(program, inputDesc.shaderTarget, nameManglingPrefix_, outputDesc.options);
            }

            /* Write header */
            if (inputDesc.entryPoint.empty())
                WriteComment("GLSL " + ToString(GetShaderTarget()));
            else
                WriteComment("GLSL " + ToString(GetShaderTarget()) + " \"" + inputDesc.entryPoint + "\"");
        
            WriteComment("Generated by XShaderCompiler");

            WriteComment(TimePoint());
            Blank();

            /* Visit program AST */
            Visit(&program);
        }
        catch (const Report& e)
        {
            throw e;
        }
        catch (const ASTRuntimeError& e)
        {
            Error(e.what(), e.GetAST());
        }
        catch (const std::exception& e)
        {
            Error(e.what());
        }
    }
    else
        Error("entry point \"" + inputDesc.entryPoint + "\" not found");
}


/*
 * ======= Private: =======
 */

std::unique_ptr<std::string> GLSLGenerator::SystemValueToKeyword(const IndexedSemantic& semantic) const
{
    if (semantic == Semantic::Target && versionOut_ > OutputShaderVersion::GLSL120)
        return MakeUnique<std::string>(semantic.ToString());
    else
        return SemanticToGLSLKeyword(semantic, IsVKSL());
}

bool GLSLGenerator::IsWrappedIntrinsic(const Intrinsic intrinsic) const
{
    static const std::set<Intrinsic> wrappedIntrinsics
    {
        Intrinsic::Clip,
        Intrinsic::SinCos,
    };
    return (wrappedIntrinsics.find(intrinsic) != wrappedIntrinsics.end());
}

bool GLSLGenerator::IsESSL() const
{
    return IsLanguageESSL(versionOut_);
}

bool GLSLGenerator::IsVKSL() const
{
    return IsLanguageVKSL(versionOut_);
}

const std::string* GLSLGenerator::BufferTypeToKeyword(const BufferType bufferType, const AST* ast)
{
    if (auto keyword = BufferTypeToGLSLKeyword(bufferType, IsVKSL()))
        return keyword;
    else
        Error("failed to map buffer type to GLSL sampler type", ast);
    return nullptr;
}

const std::string* GLSLGenerator::SamplerTypeToKeyword(const SamplerType samplerType, const AST* ast)
{
    if (auto keyword = SamplerTypeToGLSLKeyword(samplerType, IsVKSL()))
        return keyword;
    else
        Error("failed to map sampler type to GLSL sampler type", ast);
    return nullptr;
}

bool GLSLGenerator::IsTypeCompatibleWithSemantic(const Semantic semantic, const TypeDenoter& typeDenoter)
{
    if (auto baseTypeDen = typeDenoter.As<BaseTypeDenoter>())
    {
        auto dataType = baseTypeDen->dataType;

        switch (semantic)
        {
            case Semantic::DispatchThreadID:
            case Semantic::GroupID:
            case Semantic::GroupThreadID:
                return (dataType == DataType::UInt3);

            case Semantic::GroupIndex:
                return (dataType == DataType::UInt);

            case Semantic::GSInstanceID:
            case Semantic::InstanceID:
            case Semantic::OutputControlPointID:
            case Semantic::PrimitiveID:
            case Semantic::SampleIndex:
            case Semantic::VertexID:
                return (dataType == DataType::Int);

            default:
                break;
        }
        return true;
    }
    return false;
}

/* ------- Visit functions ------- */

#define IMPLEMENT_VISIT_PROC(AST_NAME) \
    void GLSLGenerator::Visit##AST_NAME(AST_NAME* ast, void* args)

IMPLEMENT_VISIT_PROC(Program)
{
    /* Write version and required extensions first */
    WriteProgramHeader();

    /* Write global input/output layouts */
    WriteGlobalLayouts();

    /* Write wrapper functions for special intrinsics */
    WriteWrapperIntrinsics();

    /* Write global uniform declarations */
    WriteGlobalUniforms();

    /* Write global input/output semantics */
    BeginSep();
    {
        WriteGlobalInputSemantics(GetProgram()->entryPointRef);
    }
    EndSep();

    BeginSep();
    {
        WriteGlobalOutputSemantics(GetProgram()->entryPointRef);
    }
    EndSep();

    /* Write global program statements */
    WriteStmntList(ast->globalStmnts, true);
}

IMPLEMENT_VISIT_PROC(CodeBlock)
{
    WriteScopeOpen();
    {
        WriteStmntList(ast->stmnts);
    }
    WriteScopeClose();
}

IMPLEMENT_VISIT_PROC(FunctionCall)
{
    /* Check for special cases of intrinsic function calls */
    if (ast->intrinsic == Intrinsic::Mul)
        WriteFunctionCallIntrinsicMul(ast);
    else if (ast->intrinsic == Intrinsic::Rcp)
        WriteFunctionCallIntrinsicRcp(ast);
    else if (ast->intrinsic == Intrinsic::Clip && ast->flags(FunctionCall::canInlineIntrinsicWrapper))
        WriteFunctionCallIntrinsicClip(ast);
    else if (ast->intrinsic >= Intrinsic::InterlockedAdd && ast->intrinsic <= Intrinsic::InterlockedXor)
        WriteFunctionCallIntrinsicAtomic(ast);
    else
        WriteFunctionCallStandard(ast);
}

IMPLEMENT_VISIT_PROC(SwitchCase)
{
    /* Write case header */
    if (ast->expr)
    {
        BeginLn();
        {
            Write("case ");
            Visit(ast->expr);
            Write(":");
        }
        EndLn();
    }
    else
        WriteLn("default:");

    /* Write statement list */
    IncIndent();
    {
        Visit(ast->stmnts);
    }
    DecIndent();
}

IMPLEMENT_VISIT_PROC(ArrayDimension)
{
    Write(ast->ToString());
}

IMPLEMENT_VISIT_PROC(TypeName)
{
    if (ast->structDecl)
        Visit(ast->structDecl);
    else
        WriteTypeDenoter(*ast->typeDenoter, IsESSL(), ast);
}

IMPLEMENT_VISIT_PROC(VarIdent)
{
    WriteVarIdent(ast);
}

/* --- Declarations --- */

IMPLEMENT_VISIT_PROC(VarDecl)
{
    Write(InsideStructDecl() ? ast->ident : ast->FinalIdent());

    Visit(ast->arrayDims);

    if (ast->initializer)
    {
        if (auto typeDen = ast->initializer->GetTypeDenoter()->Get())
        {
            if (!typeDen->IsNull())
            {
                Write(" = ");
                Visit(ast->initializer);
            }
        }
    }
}

IMPLEMENT_VISIT_PROC(StructDecl)
{
    if (ast->flags(StructDecl::isNonEntryPointParam) || !ast->flags(StructDecl::isShaderInput | StructDecl::isShaderOutput))
    {
        PushStructDecl(ast);

        /* Write all nested structures (if this is the root structure) */
        if (!ast->flags(StructDecl::isNestedStruct))
        {
            /* Write nested structres in child-to-parent order */
            for (auto nestedStruct = ast->nestedStructDeclRefs.rbegin(); nestedStruct != ast->nestedStructDeclRefs.rend(); ++nestedStruct)
            {
                if (WriteStructDecl(*nestedStruct, true, true))
                    Blank();
            }
        }

        /* Write declaration of this structure (without nested structures) */
        if (auto structDeclArgs = reinterpret_cast<StructDeclArgs*>(args))
            structDeclArgs->outStructWritten = WriteStructDecl(ast, structDeclArgs->inEndWithSemicolon);
        else
            WriteStructDecl(ast, false);

        PopStructDecl();
    }
}

/* --- Declaration statements --- */

IMPLEMENT_VISIT_PROC(FunctionDecl)
{
    /* Is this function reachable from the entry point? */
    if (!ast->flags(AST::isReachable))
    {
        /* Check for valid control paths */
        if (ast->flags(FunctionDecl::hasNonReturnControlPath))
            Warning("not all control paths in unreferenced function '" + ast->ident + "' return a value", ast);
        return;
    }

    /* Check for valid control paths */
    if (ast->flags(FunctionDecl::hasNonReturnControlPath))
        Error("not all control paths in function '" + ast->ident + "' return a value", ast);

    /* Write line */
    WriteLineMark(ast);

    /* Write function declaration */
    PushFunctionDecl(ast);
    {
        if (ast->flags(FunctionDecl::isEntryPoint))
            WriteFunctionEntryPoint(ast);
        else if (ast->flags(FunctionDecl::isSecondaryEntryPoint))
            WriteFunctionSecondaryEntryPoint(ast);
        else
            WriteFunction(ast);
    }
    PopFunctionDecl();

    Blank();
}

IMPLEMENT_VISIT_PROC(UniformBufferDecl)
{
    if (!ast->flags(AST::isReachable))
        return;

    if (versionOut_ < OutputShaderVersion::GLSL140)
    {
        /* Write individual uniforms */
        for (auto& varDeclStmnt : ast->members)
        {
            varDeclStmnt->isUniform = true;
            Visit(varDeclStmnt);
        }
    }
    else
    {
        /* Write uniform buffer header */
        WriteLineMark(ast);

        /* Write uniform buffer declaration */
        BeginLn();
        Write("layout(std140");

        if (explicitBinding_)
        {
            if (auto slotRegister = Register::GetForTarget(ast->slotRegisters, GetShaderTarget()))
                Write(", binding = " + std::to_string(slotRegister->slot));
        }

        Write(") uniform ");
        Write(ast->ident);

        /* Write uniform buffer members */
        WriteScopeOpen(false, true);
        BeginSep();
        {
            isInsideUniformBuffer_ = true;

            Visit(ast->members);

            isInsideUniformBuffer_ = false;
        }
        EndSep();
        WriteScopeClose();
    }

    Blank();
}

IMPLEMENT_VISIT_PROC(BufferDeclStmnt)
{
    if (ast->flags(AST::isReachable))
    {
        /* Write buffer declarations */
        for (auto& bufferDecl : ast->bufferDecls)
            WriteBufferDecl(bufferDecl.get());
    }
}

IMPLEMENT_VISIT_PROC(StructDeclStmnt)
{
    if (!ast->structDecl->flags(AST::isReachable))
        return;

    if (ast->structDecl->flags(StructDecl::isNonEntryPointParam) || !ast->structDecl->flags(StructDecl::isShaderInput | StructDecl::isShaderOutput))
    {
        WriteLineMark(ast);

        StructDeclArgs structDeclArgs;
        structDeclArgs.inEndWithSemicolon = true;

        Visit(ast->structDecl, &structDeclArgs);

        if (structDeclArgs.outStructWritten)
            Blank();
    }
}

IMPLEMENT_VISIT_PROC(VarDeclStmnt)
{
    auto varDecls = ast->varDecls;

    //TODO: refactor this!
    #if 1
    for (auto it = varDecls.begin(); it != varDecls.end();)
    {
        auto var = it->get();
        const auto& baseVarType = var->GetTypeDenoter()->GetBase();

        StructDecl* structDecl = nullptr;
        if (auto structTypeDen = baseVarType.As<const StructTypeDenoter>())
            structDecl = structTypeDen->structDeclRef;

        /*
        First check if code generation is disabled for variable declaration,
        then check if this is a system value semantic inside an interface block.
        */
        if ( ( var->flags(VarDecl::isEntryPointLocal) && ( !structDecl || !structDecl->flags(StructDecl::isNonEntryPointParam) ) ) ||
             ( isInsideInterfaceBlock_ && var->semantic.IsSystemValue() ) )
        {
            /*
            Code generation is disabled for this variable declaration
            -> Remove this from the list
            */
            it = varDecls.erase(it);
        }
        else
            ++it;
    }

    if (varDecls.empty())
    {
        /*
        All variable declarations within this statement are disabled
        -> Break code generation here
        */
        return;
    }
    #endif

    BeginLn();

    /* Write storage classes and interpolation modifiers (must be before in/out keywords) */
    WriteInterpModifiers(ast->interpModifiers, ast);
    WriteStorageClasses(ast->storageClasses, ast);
    Separator();

    /* Write input modifiers */
    if (ast->flags(VarDeclStmnt::isShaderInput))
        Write("in ");
    else if (ast->flags(VarDeclStmnt::isShaderOutput))
        Write("out ");
    else if (ast->isUniform)
        Write("uniform ");

    Separator();

    /* Write type modifiers */
    WriteTypeModifiers(ast->typeModifiers, ast->varType->GetTypeDenoter()->Get());
    Separator();

    /* Write variable type */
    if (ast->varType->structDecl)
    {
        /* Do not end line here with "EndLn" */
        Visit(ast->varType);
        BeginLn();
    }
    else
    {
        Visit(ast->varType);
        Write(" ");
    }

    Separator();

    /* Write variable declarations */
    for (std::size_t i = 0; i < varDecls.size(); ++i)
    {
        Visit(varDecls[i]);
        if (i + 1 < varDecls.size())
            Write(", ");
    }

    Write(";");
    EndLn();
}

IMPLEMENT_VISIT_PROC(AliasDeclStmnt)
{
    if (ast->structDecl && !ast->structDecl->IsAnonymous())
    {
        WriteLineMark(ast);

        StructDeclArgs structDeclArgs;
        structDeclArgs.inEndWithSemicolon = true;

        Visit(ast->structDecl, &structDeclArgs);

        if (structDeclArgs.outStructWritten)
            Blank();
    }
}

/* --- Statements --- */

IMPLEMENT_VISIT_PROC(NullStmnt)
{
    WriteLn(";");
}

IMPLEMENT_VISIT_PROC(CodeBlockStmnt)
{
    Visit(ast->codeBlock);
}

IMPLEMENT_VISIT_PROC(ForLoopStmnt)
{
    /* Write loop header */
    BeginLn();
    
    Write("for (");

    PushOptions({ false, false });
    {
        Visit(ast->initSmnt);
        Write(" "); // initStmnt already has the ';'!
        Visit(ast->condition);
        Write("; ");
        Visit(ast->iteration);
    }
    PopOptions();

    Write(")");

    WriteScopedStmnt(ast->bodyStmnt.get());
}

IMPLEMENT_VISIT_PROC(WhileLoopStmnt)
{
    /* Write loop condExpr */
    BeginLn();
    
    Write("while (");
    Visit(ast->condition);
    Write(")");

    WriteScopedStmnt(ast->bodyStmnt.get());
}

IMPLEMENT_VISIT_PROC(DoWhileLoopStmnt)
{
    BeginLn();

    Write("do");
    WriteScopedStmnt(ast->bodyStmnt.get());

    /* Write loop condExpr */
    WriteScopeContinue();
    
    Write("while (");
    Visit(ast->condition);
    Write(");");
    
    EndLn();
}

IMPLEMENT_VISIT_PROC(IfStmnt)
{
    bool hasElseParentNode = (args != nullptr ? reinterpret_cast<IfStmntArgs*>(args)->inHasElseParentNode : false);

    /* Write if condExpr */
    if (!hasElseParentNode)
        BeginLn();
    
    Write("if (");
    Visit(ast->condition);
    Write(")");
    
    /* Write if body */
    WriteScopedStmnt(ast->bodyStmnt.get());

    Visit(ast->elseStmnt);
}

IMPLEMENT_VISIT_PROC(ElseStmnt)
{
    if (ast->bodyStmnt->Type() == AST::Types::IfStmnt)
    {
        /* Write else if statement */
        WriteScopeContinue();
        Write("else ");

        if (ast->bodyStmnt->Type() == AST::Types::IfStmnt)
        {
            IfStmntArgs ifStmntArgs;
            ifStmntArgs.inHasElseParentNode = true;
            Visit(ast->bodyStmnt, &ifStmntArgs);
        }
        else
            Visit(ast->bodyStmnt);
    }
    else
    {
        /* Write else statement */
        WriteScopeContinue();
        Write("else");
        WriteScopedStmnt(ast->bodyStmnt.get());
    }
}

IMPLEMENT_VISIT_PROC(SwitchStmnt)
{
    /* Write selector */
    BeginLn();
    
    Write("switch (");
    Visit(ast->selector);
    Write(")");

    /* Write switch cases */
    WriteScopeOpen();
    {
        Visit(ast->cases);
    }
    WriteScopeClose();
}

IMPLEMENT_VISIT_PROC(ExprStmnt)
{
    BeginLn();
    {
        Visit(ast->expr);
        Write(";");
    }
    EndLn();
}

IMPLEMENT_VISIT_PROC(ReturnStmnt)
{
    if (InsideEntryPoint() || InsideSecondaryEntryPoint())
    {
        /* Write all output semantics assignment with the expression of the return statement */
        WriteOutputSemanticsAssignment(ast->expr.get());

        /* Is this return statement at the end of the function scope? */
        if (!ast->flags(ReturnStmnt::isEndOfFunction))
            WriteLn("return;");
    }
    else
    {
        if (ast->expr)
        {
            BeginLn();
            {
                Write("return ");
                Visit(ast->expr);
                Write(";");
            }
            EndLn();
        }
        else if (!ast->flags(ReturnStmnt::isEndOfFunction))
            WriteLn("return;");
    }
}

IMPLEMENT_VISIT_PROC(CtrlTransferStmnt)
{
    WriteLn(CtrlTransformToString(ast->transfer) + ";");
}

/* --- Expressions --- */

IMPLEMENT_VISIT_PROC(ListExpr)
{
    Visit(ast->firstExpr);
    Write(", ");
    Visit(ast->nextExpr);
}

IMPLEMENT_VISIT_PROC(LiteralExpr)
{
    Write(ast->value);
}

IMPLEMENT_VISIT_PROC(TypeNameExpr)
{
    WriteTypeDenoter(*ast->typeName->typeDenoter, false, ast);
}

IMPLEMENT_VISIT_PROC(TernaryExpr)
{
    Visit(ast->condExpr);
    Write(" ? ");
    Visit(ast->thenExpr);
    Write(" : ");
    Visit(ast->elseExpr);
}

IMPLEMENT_VISIT_PROC(BinaryExpr)
{
    Visit(ast->lhsExpr);
    Write(" " + BinaryOpToString(ast->op) + " ");
    Visit(ast->rhsExpr);
}

IMPLEMENT_VISIT_PROC(UnaryExpr)
{
    Write(UnaryOpToString(ast->op));
    Visit(ast->expr);
}

IMPLEMENT_VISIT_PROC(PostUnaryExpr)
{
    Visit(ast->expr);
    Write(UnaryOpToString(ast->op));
}

IMPLEMENT_VISIT_PROC(FunctionCallExpr)
{
    Visit(ast->call);
}

IMPLEMENT_VISIT_PROC(BracketExpr)
{
    Write("(");
    Visit(ast->expr);
    Write(")");
}

IMPLEMENT_VISIT_PROC(SuffixExpr)
{
    Visit(ast->expr);
    Write(".");
    Visit(ast->varIdent);
}

IMPLEMENT_VISIT_PROC(ArrayAccessExpr)
{
    Visit(ast->expr);
    WriteArrayIndices(ast->arrayIndices);
}

IMPLEMENT_VISIT_PROC(CastExpr)
{
    Visit(ast->typeExpr);
    Write("(");
    Visit(ast->expr);
    Write(")");
}

IMPLEMENT_VISIT_PROC(VarAccessExpr)
{
    if (ast->varIdent->flags(VarIdent::isImmutable))
        Visit(ast->varIdent);
    else
        WriteVarIdentOrSystemValue(ast->varIdent.get());
    
    if (ast->assignExpr)
    {
        Write(" " + AssignOpToString(ast->assignOp) + " ");
        Visit(ast->assignExpr);
    }
}

IMPLEMENT_VISIT_PROC(InitializerExpr)
{
    Write("{ ");
        
    for (std::size_t i = 0; i < ast->exprs.size(); ++i)
    {
        Visit(ast->exprs[i]);
        if (i + 1 < ast->exprs.size())
            Write(", ");
    }

    Write(" }");
}

#undef IMPLEMENT_VISIT_PROC

/* --- Helper functions for code generation --- */

/* --- Basics --- */

void GLSLGenerator::WriteComment(const std::string& text)
{
    std::size_t start = 0, end = 0;

    while (end < text.size())
    {
        /* Get next comment line */
        end = text.find('\n', start);

        auto line = (end < text.size() ? text.substr(start, end - start) : text.substr(start));

        #if 0
        /* Get line boundaries */
        bool firstLine  = (start == 0);
        bool lastLine   = (end == std::string::npos);
        #endif

        /* Write comment line */
        BeginLn();
        {
            Write("// ");
            Write(line);
        }
        EndLn();

        start = end + 1;
    }
}

void GLSLGenerator::WriteLineMark(int lineNumber)
{
    if (allowLineMarks_)
        WriteLn("#line " + std::to_string(lineNumber));
}

void GLSLGenerator::WriteLineMark(const TokenPtr& tkn)
{
    WriteLineMark(tkn->Pos().Row());
}

void GLSLGenerator::WriteLineMark(const AST* ast)
{
    WriteLineMark(ast->area.Pos().Row());
}

/* --- Program --- */

void GLSLGenerator::WriteProgramHeader()
{
    try
    {
        /* Determine all required GLSL extensions with the GLSL extension agent */
        GLSLExtensionAgent extensionAgent;
        auto requiredExtensions = extensionAgent.DetermineRequiredExtensions(
            *GetProgram(), versionOut_, GetShaderTarget(), allowExtensions_, explicitBinding_
        );

        /* Write GLSL version */
        WriteProgramHeaderVersion();
        Blank();

        /* Write all required extensions */
        if (!requiredExtensions.empty())
        {
            for (const auto& ext : requiredExtensions)
                WriteProgramHeaderExtension(ext);
            Blank();
        }
    }
    catch (const std::exception& e)
    {
        Error(e.what());
    }
}

void GLSLGenerator::WriteProgramHeaderVersion()
{
    /* Convert output shader version into GLSL version number (with bitwise AND operator) */
    int versionNumber = (static_cast<int>(versionOut_)) & static_cast<int>(OutputShaderVersion::GLSL);
    WriteLn("#version " + std::to_string(versionNumber));
}

void GLSLGenerator::WriteProgramHeaderExtension(const std::string& extensionName)
{
    WriteLn("#extension " + extensionName + " : enable");// "require" or "enable"
}

/* --- Layouts --- */

void GLSLGenerator::WriteGlobalLayouts()
{
    auto program = GetProgram();

    bool layoutsWritten = false;

    switch (GetShaderTarget())
    {
        case ShaderTarget::TessellationControlShader:
            layoutsWritten = WriteGlobalLayoutsTessControl(program->layoutTessControl);
            break;
        case ShaderTarget::TessellationEvaluationShader:
            layoutsWritten = WriteGlobalLayoutsTessEvaluation(program->layoutTessEvaluation);
            break;
        case ShaderTarget::GeometryShader:
            layoutsWritten = WriteGlobalLayoutsGeometry(program->layoutGeometry);
            break;
        case ShaderTarget::FragmentShader:
            layoutsWritten = WriteGlobalLayoutsFragment(program->layoutFragment);
            break;
        case ShaderTarget::ComputeShader:
            layoutsWritten = WriteGlobalLayoutsCompute(program->layoutCompute);
            break;
        default:
            break;
    }

    if (layoutsWritten)
        Blank();
}

bool GLSLGenerator::WriteGlobalLayoutsTessControl(const Program::LayoutTessControlShader& layout)
{
    WriteLn("layout(vertices = " + std::to_string(layout.outputControlPoints) + ") in;");
    return true;
}

bool GLSLGenerator::WriteGlobalLayoutsTessEvaluation(const Program::LayoutTessEvaluationShader& layout)
{
    BeginLn();
    {
        Write("layout(");

        /* Map GLSL domain type (abstract patch type) */
        if (auto keyword = AttributeValueToGLSLKeyword(layout.domainType))
            Write(*keyword);
        else
            Error("failed to map domain type to GLSL keyword (tessellation abstract patch type)");

        if (IsAttributeValuePartitioning(layout.partitioning))
        {
            Write(", ");

            /* Map GLSL partitioning (spacing) */
            if (auto keyword = AttributeValueToGLSLKeyword(layout.partitioning))
                Write(*keyword);
            else
                Error("failed to map partitioning to GLSL keyword (tessellation spacing)");
        }

        if (IsAttributeValueTrianglePartitioning(layout.outputTopology))
        {
            Write(", ");

            /* Map GLSL output topology (primitive ordering) */
            if (auto keyword = AttributeValueToGLSLKeyword(layout.outputTopology))
                Write(*keyword);
            else
                Error("failed to map output toplogy to GLSL keyword (tessellation primitive orderin)");
        }

        Write(") in;");
    }
    EndLn();
    return true;
}

bool GLSLGenerator::WriteGlobalLayoutsGeometry(const Program::LayoutGeometryShader& layout)
{
    /* Write input layout */
    BeginLn();
    {
        Write("layout(");

        /* Map GLSL input primitive */
        if (auto keyword = PrimitiveTypeToGLSLKeyword(layout.inputPrimitive))
            Write(*keyword);
        else
            Error("failed to map input geometry primitive to GLSL keyword");

        Write(") in;");
    }
    EndLn();

    /* Write output layout */
    BeginLn();
    {
        Write("layout(");

        /* Map GLSL output primitive */
        if (auto keyword = BufferTypeToGLSLKeyword(layout.outputPrimitive))
            Write(*keyword);
        else
            Error("failed to map output geometry primitive to GLSL keyword");

        Write(", max_vertices = " + std::to_string(layout.maxVertices) + ") out;");
    }
    EndLn();

    return true;
}

bool GLSLGenerator::WriteGlobalLayoutsFragment(const Program::LayoutFragmentShader& layout)
{
    bool layoutsWritten = false;

    if (GetProgram()->layoutFragment.fragCoordUsed)
    {
        BeginLn();
        {
            Write("layout(origin_upper_left");
            if (layout.pixelCenterInteger)
                Write(", pixel_center_integer");
            Write(") in vec4 gl_FragCoord;");
        }
        EndLn();
        layoutsWritten = true;
    }

    if (layout.earlyDepthStencil)
    {
        WriteLn("layout(early_fragment_tests) in;");
        layoutsWritten = true;
    }

    return layoutsWritten;
}

bool GLSLGenerator::WriteGlobalLayoutsCompute(const Program::LayoutComputeShader& layout)
{
    BeginLn();
    {
        Write("layout(");
        Write("local_size_x = " + std::to_string(layout.numThreads[0]) + ", ");
        Write("local_size_y = " + std::to_string(layout.numThreads[1]) + ", ");
        Write("local_size_z = " + std::to_string(layout.numThreads[2]));
        Write(") in;");
    }
    EndLn();
    return true;
}

/* --- Input semantics --- */

void GLSLGenerator::WriteLocalInputSemantics(FunctionDecl* entryPoint)
{
    entryPoint->inputSemantics.ForEach(
        [this](VarDecl* varDecl)
        {
            if (varDecl->flags(VarDecl::isWrittenTo))
                WriteLocalInputSemanticsVarDecl(varDecl);
        }
    );

    for (auto& param : entryPoint->parameters)
    {
        if (auto varType = param->varType->GetTypeDenoter()->Get())
        {
            if (auto structTypeDen = varType->As<StructTypeDenoter>())
                WriteLocalInputSemanticsStructDeclParam(param.get(), structTypeDen->structDeclRef);
        }
    }
}

void GLSLGenerator::WriteLocalInputSemanticsVarDecl(VarDecl* varDecl)
{
    /* Is semantic of the variable declaration a system value semantic? */
    auto semanticKeyword = SystemValueToKeyword(varDecl->semantic);

    if (!semanticKeyword)
    {
        semanticKeyword = MakeUnique<std::string>(varDecl->FinalIdent());
        varDecl->renamedIdent = (nameManglingPrefix_ + "temp_" + varDecl->ident);
    }

    /* Write local variable definition statement */
    BeginLn();
    {
        /* Write desired variable type and identifier */
        auto varType = varDecl->declStmntRef->varType.get();

        Visit(varType);
        Write(" " + varDecl->FinalIdent() + " = ");

        /* Is a type conversion required? */
        if (!IsTypeCompatibleWithSemantic(varDecl->semantic, *varType->typeDenoter->Get()))
        {
            /* Write type cast with semantic keyword */
            Visit(varType);
            Write("(" + *semanticKeyword + ");");
        }
        else
        {
            /* Write semantic keyword */
            Write(*semanticKeyword + ";");
        }
    }
    EndLn();
}

void GLSLGenerator::WriteLocalInputSemanticsStructDeclParam(VarDeclStmnt* param, StructDecl* structDecl)
{
    if (structDecl && structDecl->flags(StructDecl::isNonEntryPointParam) && structDecl->flags(StructDecl::isShaderInput))
    {
        /* Write parameter as variable declaration */
        Visit(param);

        /* Write global shader input to local variable assignments */
        auto paramVar = param->varDecls.front().get();

        structDecl->ForEachVarDecl(
            [&](VarDeclPtr& varDecl)
            {
                WriteLn(
                    paramVar->ident + "." + varDecl->ident + " = " + varDecl->FinalIdent() + ";"
                );
            }
        );
    }
}

void GLSLGenerator::WriteGlobalInputSemantics(FunctionDecl* entryPoint)
{
    auto& varDeclRefs = entryPoint->inputSemantics.varDeclRefs;

    for (auto varDecl : varDeclRefs)
        WriteGlobalInputSemanticsVarDecl(varDecl);

    if (!varDeclRefs.empty())
        Blank();
}

void GLSLGenerator::WriteGlobalInputSemanticsVarDecl(VarDecl* varDecl)
{
    /* Write global variable definition statement */
    BeginLn();
    {
        if (versionOut_ <= OutputShaderVersion::GLSL120)
        {
            if (!varDecl->declStmntRef->interpModifiers.empty())
                Warning("interpolation modifiers not supported for GLSL version 120 or below", varDecl);

            if (IsVertexShader())
                Write("attribute ");
            else
                Write("varying ");
            Separator();
        }
        else
        {
            WriteInterpModifiers(varDecl->declStmntRef->interpModifiers, varDecl->declStmntRef);
            Separator();

            if (explicitBinding_ && IsVertexShader() && varDecl->semantic.IsValid())
            {
                auto it = vertexShaderInputSemanticMapping_.find(ToCiString(varDecl->semantic.ToString()));
                if (it != vertexShaderInputSemanticMapping_.end())
                    Write("layout(location = " + std::to_string(it->second) + ") in ");
                else
                    Write("in ");
            }
            else
                Write("in ");
            Separator();
        }

        Visit(varDecl->declStmntRef->varType);
        Separator();

        Write(" " + varDecl->FinalIdent());

        if (varDecl->flags(VarDecl::isDynamicArray))
            Write("[]");

        Write(";");
    }
    EndLn();
}

/* --- Output semantics --- */

void GLSLGenerator::WriteLocalOutputSemantics(FunctionDecl* entryPoint)
{
    //TODO: maybe remove this??? (currently unused)
    #if 0
    entryPoint->outputSemantics.ForEach(
        [this](VarDecl* varDecl)
        {
            if (varDecl->flags(VarDecl::isWrittenTo))
                WriteLocalOutputSemanticsVarDecl(varDecl);
        }
    );
    #endif

    for (auto& param : entryPoint->parameters)
    {
        if (auto varType = param->varType->GetTypeDenoter()->Get())
        {
            if (auto structTypeDen = varType->As<StructTypeDenoter>())
                WriteLocalOutputSemanticsStructDeclParam(param.get(), structTypeDen->structDeclRef);
        }
    }
}

void GLSLGenerator::WriteLocalOutputSemanticsVarDecl(VarDecl* varDecl)
{
    /* Write local variable definition statement (without initialization) */
    BeginLn();
    {
        Visit(varDecl->declStmntRef->varType);
        Write(" " + varDecl->FinalIdent() + ";");
    }
    EndLn();
}

void GLSLGenerator::WriteLocalOutputSemanticsStructDeclParam(VarDeclStmnt* param, StructDecl* structDecl)
{
    if (structDecl && structDecl->flags(StructDecl::isNonEntryPointParam) && structDecl->flags(StructDecl::isShaderOutput))
    {
        /* Write parameter as variable declaration */
        Visit(param);
    }
}

void GLSLGenerator::WriteGlobalOutputSemantics(FunctionDecl* entryPoint)
{
    /* Write non-system-value output semantics */
    auto& varDeclRefs = entryPoint->outputSemantics.varDeclRefs;

    bool paramsWritten = (!varDeclRefs.empty());

    for (auto varDecl : varDeclRefs)
        WriteGlobalOutputSemanticsVarDecl(varDecl);

    /* Write 'SV_Target' system-value output semantics */
    if (IsFragmentShader() && versionOut_ > OutputShaderVersion::GLSL120)
    {
        /* Write 'SV_Target' system-value output semantics from variables */
        auto& varDeclRefs = entryPoint->outputSemantics.varDeclRefsSV;

        for (auto varDecl : varDeclRefs)
        {
            if (varDecl->semantic == Semantic::Target)
            {
                WriteGlobalOutputSemanticsVarDecl(varDecl, true);
                paramsWritten = true;
            }
        }

        /* Write 'SV_Target' system-value output semantic from entry point return semantic */
        if (entryPoint->semantic == Semantic::Target)
        {
            WriteGlobalOutputSemanticsSlot(
                entryPoint->returnType.get(),
                entryPoint->semantic,
                entryPoint->semantic.ToString()
            );
            paramsWritten = true;
        }
    }

    if (paramsWritten)
        Blank();
}

void GLSLGenerator::WriteGlobalOutputSemanticsVarDecl(VarDecl* varDecl, bool useSemanticName)
{
    /* Write global variable definition statement */
    WriteGlobalOutputSemanticsSlot(
        varDecl->declStmntRef->varType.get(),
        varDecl->semantic,
        (useSemanticName ? varDecl->semantic.ToString() : varDecl->FinalIdent()),
        varDecl
    );
}

void GLSLGenerator::WriteGlobalOutputSemanticsSlot(TypeName* varType, const IndexedSemantic& semantic, const std::string& ident, VarDecl* varDecl)
{
    /* Write global output semantic slot */
    BeginLn();
    {
        VarDeclStmnt* varDeclStmnt = (varDecl != nullptr ? varDecl->declStmntRef : nullptr);

        if (versionOut_ <= OutputShaderVersion::GLSL120)
        {
            if (varDeclStmnt && !varDeclStmnt->interpModifiers.empty())
                Warning("interpolation modifiers not supported for GLSL version 120 or below", varDecl);

            Write("varying ");
            Separator();
        }
        else
        {
            if (varDeclStmnt)
                WriteInterpModifiers(varDeclStmnt->interpModifiers, varDecl);
            Separator();

            if (semantic.IsSystemValue() && explicitBinding_)
                Write("layout(location = " + std::to_string(semantic.Index()) + ") out ");
            else
                Write("out ");
            Separator();
        }

        Visit(varType);
        Separator();

        Write(" " + ident);

        if (varDecl && varDecl->flags(VarDecl::isDynamicArray))
            Write("[]");

        Write(";");
    }
    EndLn();
}

void GLSLGenerator::WriteOutputSemanticsAssignment(Expr* ast)
{
    auto        entryPoint  = GetProgram()->entryPointRef;
    auto        semantic    = entryPoint->semantic;
    const auto& varDeclRefs = entryPoint->outputSemantics.varDeclRefsSV;

    /* Write wrapped structures */
    for (const auto& paramStruct : entryPoint->paramStructs)
        WriteOutputSemanticsAssignmentStructDeclParam(paramStruct.paramVar, paramStruct.structDecl);

    /* Prefer variables from structure, rather than function return semantic */
    if (!varDeclRefs.empty())
    {
        #if 0
        /* Write system values */
        for (auto varDecl : varDeclRefs)
        {
            if (varDecl->semantic.IsValid() && varDecl->flags(VarDecl::isWrittenTo))
            {
                if (auto semanticKeyword = SystemValueToKeyword(varDecl->semantic))
                    WriteLn(*semanticKeyword + " = " + varDecl->FinalIdent() + ";");
            }
        }
        #endif
    }
    else if (semantic.IsSystemValue() && ast)
    {
        if (auto semanticKeyword = SystemValueToKeyword(semantic))
        {
            BeginLn();
            {
                Write(*semanticKeyword);
                Write(" = ");
                Visit(ast);
                Write(";");
            }
            EndLn();
        }
        else
            Error("failed to map output semantic to GLSL keyword", entryPoint);
    }
    else if (IsFragmentShader())
        Error("missing output semantic", ast);
}

void GLSLGenerator::WriteOutputSemanticsAssignmentStructDeclParam(VarDecl* paramVar, StructDecl* structDecl)
{
    if (structDecl && structDecl->flags(StructDecl::isNonEntryPointParam) && structDecl->flags(StructDecl::isShaderOutput))
    {
        /* Write global shader input to local variable assignments */
        structDecl->ForEachVarDecl(
            [&](VarDeclPtr& varDecl)
            {
                if (auto semanticKeyword = SystemValueToKeyword(varDecl->semantic))
                    WriteLn(*semanticKeyword + " = " + paramVar->ident + "." + varDecl->ident + ";");
                else
                    WriteLn(varDecl->FinalIdent() + " = " + paramVar->ident + "." + varDecl->ident + ";");
            }
        );
    }
}

/* --- Uniforms --- */

void GLSLGenerator::WriteGlobalUniforms()
{
    bool uniformsWritten = false;

    for (auto& param : GetProgram()->entryPointRef->parameters)
    {
        if (param->isUniform)
        {
            WriteGlobalUniformsParameter(param.get());
            uniformsWritten = true;
        }
    }

    if (uniformsWritten)
        Blank();
}

void GLSLGenerator::WriteGlobalUniformsParameter(VarDeclStmnt* param)
{
    /* Write uniform type */
    BeginLn();
    {
        Write("uniform ");
        Visit(param->varType);
        Write(" ");

        /* Write parameter identifier */
        if (param->varDecls.size() == 1)
            Visit(param->varDecls.front());
        else
            Error("invalid number of variables in function parameter", param);

        Write(";");
    }
    EndLn();
}

/* --- VarIdent --- */

/*
Find the first VarIdent with a system value semantic,
and keep the remaining AST nodes (i.e. ast->next) which might be vector subscriptions (e.g. "gl_Position.xyz").
*/
VarIdent* GLSLGenerator::FindSystemValueVarIdent(VarIdent* ast)
{
    while (ast)
    {
        /* Check if current var-ident AST node has a system semantic */
        if (SystemValueToKeyword(ast->FetchSemantic()) != nullptr)
            return ast;

        /* Search in next var-ident AST node */
        ast = ast->next.get();
    }
    return nullptr;
}

const std::string& GLSLGenerator::FinalIdentFromVarIdent(VarIdent* ast)
{
    /* Check if a variable declaration has changed it's name during conversion */
    if (ast->symbolRef)
    {
        if (auto varDecl = ast->symbolRef->As<VarDecl>())
            return varDecl->FinalIdent();
        if (auto funcDecl = ast->symbolRef->As<FunctionDecl>())
            return funcDecl->FinalIdent();
    }

    /* Return default identifier */
    return ast->ident;
}

void GLSLGenerator::WriteVarIdent(VarIdent* ast, bool recursive)
{
    /* Write identifier */
    Write(FinalIdentFromVarIdent(ast));

    /* Write array index expressions */
    WriteArrayIndices(ast->arrayIndices);

    if (recursive && ast->next)
    {
        Write(".");
        WriteVarIdent(ast->next.get());
    }
}

/*
Writes either the variable identifier as it is (e.g. "vertexOutput.position.xyz"),
or a system value if the identifier has a system value semantix (e.g. "gl_Position.xyz").
*/
void GLSLGenerator::WriteVarIdentOrSystemValue(VarIdent* ast)
{
    /* Find system value semantic in variable identifier */
    auto semanticVarIdent = FindSystemValueVarIdent(ast);
    std::unique_ptr<std::string> semanticKeyword;

    if (semanticVarIdent)
    {
        if (auto varDecl = semanticVarIdent->FetchVarDecl())
        {
            /* Is this variable an entry-point output semantic, or an r-value? */
            if (GetProgram()->entryPointRef->outputSemantics.Contains(varDecl) || !varDecl->flags(VarDecl::isWrittenTo))
                semanticKeyword = SystemValueToKeyword(varDecl->semantic);
        }
    }

    if (semanticVarIdent && semanticKeyword)
    {
        /* Write shader target respective system semantic */
        Write(*semanticKeyword);

        if (semanticVarIdent->next)
        {
            Write(".");
            Visit(semanticVarIdent->next);
        }
    }
    else
    {
        /* Write default variable identifier */
        Visit(ast);
    }
}

static TypeDenoterPtr GetTypeDenoterForSuffixVarIdent(const TypeDenoter& lhsTypeDen, VarIdent* ast)
{
    if (lhsTypeDen.IsBase())
    {
        /* Get type denoter from vector subscript */
        auto lhsBaseTypeDen = lhsTypeDen.As<BaseTypeDenoter>();
        auto subscriptDataType = SubscriptDataType(lhsBaseTypeDen->dataType, ast->ident);
        return std::make_shared<BaseTypeDenoter>(subscriptDataType);
    }
    else
    {
        /* Get type denoter from symbol reference (in VarIdent) */
        return ast->GetExplicitTypeDenoter(false)->Get();
    }
}

/* --- Type denoter --- */

void GLSLGenerator::WriteStorageClasses(const std::set<StorageClass>& storageClasses, const AST* ast)
{
    for (auto storage : storageClasses)
    {
        if (auto keyword = StorageClassToGLSLKeyword(storage))
            Write(*keyword + " ");
        else
            Warning("not all storage classes can be mapped to GLSL keywords", ast);
    }
}

void GLSLGenerator::WriteInterpModifiers(const std::set<InterpModifier>& interpModifiers, const AST* ast)
{
    for (auto modifier : interpModifiers)
    {
        if (auto keyword = InterpModifierToGLSLKeyword(modifier))
            Write(*keyword + " ");
        else
            Warning("not all interpolation modifiers can be mapped to GLSL keywords", ast);
    }
}

void GLSLGenerator::WriteTypeModifiers(const std::set<TypeModifier>& typeModifiers, const TypeDenoterPtr& typeDenoter)
{
    /* Matrix packing alignment can only be written for uniform buffers */
    if (isInsideUniformBuffer_ && typeDenoter && typeDenoter->IsMatrix())
    {
        /* Only write 'row_major' type modifier (column major is the default) */
        if (typeModifiers.find(TypeModifier::RowMajor) != typeModifiers.end())
            Write("layout(row_major) ");
    }

    /* Write const type modifier */
    if (typeModifiers.find(TypeModifier::Const) != typeModifiers.end())
        Write("const ");
}

void GLSLGenerator::WriteDataType(DataType dataType, bool writePrecisionSpecifier, const AST* ast)
{
    /* Replace doubles with floats, if doubles are not supported */
    if (versionOut_ < OutputShaderVersion::GLSL400)
        dataType = DoubleToFloatDataType(dataType);

    /* Write optional precision specifier */
    if (writePrecisionSpecifier)
    {
        if (IsHalfRealType(dataType))
            Write("mediump ");
        else
            Write("highp ");
    }

    /* Map GLSL data type */
    if (auto keyword = DataTypeToGLSLKeyword(dataType))
        Write(*keyword);
    else
        Error("failed to map data type to GLSL keyword", ast);
}

void GLSLGenerator::WriteTypeDenoter(const TypeDenoter& typeDenoter, bool writePrecisionSpecifier, const AST* ast)
{
    try
    {
        if (typeDenoter.IsVoid())
        {
            /* Just write void type */
            Write("void");
        }
        else if (auto baseTypeDen = typeDenoter.As<BaseTypeDenoter>())
        {
            /* Map GLSL base type */
            WriteDataType(baseTypeDen->dataType, writePrecisionSpecifier, ast);
        }
        else if (auto bufferTypeDen = typeDenoter.As<BufferTypeDenoter>())
        {
            /* Get buffer type */
            auto bufferType = bufferTypeDen->bufferType;
            if (bufferType == BufferType::Undefined)
            {
                if (auto bufferDecl = bufferTypeDen->bufferDeclRef)
                    bufferType = bufferDecl->GetBufferType();
                else
                    Error("missing reference to declaration in buffer type denoter", ast);
            }

            /* Convert buffer type to GLSL buffer (or sampler type) */
            if (auto keyword = BufferTypeToKeyword(bufferType, ast))
                Write(*keyword);
        }
        else if (auto samplerTypeDen = typeDenoter.As<SamplerTypeDenoter>())
        {
            /* Get sampler type */
            auto samplerType = samplerTypeDen->samplerType;
            if (samplerType == SamplerType::Undefined)
            {
                if (auto samplerDecl = samplerTypeDen->samplerDeclRef)
                    samplerType = samplerDecl->GetSamplerType();
                else
                    Error("missing reference to declaration in sampler type denoter", ast);
            }

            if (!IsSamplerStateType(samplerType))
            {
                /* Convert sampler type to GLSL sampler type */
                if (auto keyword = SamplerTypeToKeyword(samplerType, ast))
                    Write(*keyword);
            }
            else
                Error("can not translate sampler state object to GLSL sampler", ast);
        }
        else if (typeDenoter.IsStruct())
        {
            /* Write struct identifier */
            Write(typeDenoter.Ident());
        }
        else if (typeDenoter.IsAlias())
        {
            /* Write aliased type denoter */
            WriteTypeDenoter(typeDenoter.GetAliased(), writePrecisionSpecifier, ast);
        }
        else if (auto arrayTypeDen = typeDenoter.As<ArrayTypeDenoter>())
        {
            /* Write array type denoter */
            WriteTypeDenoter(*arrayTypeDen->baseTypeDenoter, writePrecisionSpecifier, ast);
            Visit(arrayTypeDen->arrayDims);
        }
        else
            Error("failed to determine GLSL data type", ast);
    }
    catch (const Report& e)
    {
        throw e;
    }
    catch (const std::exception& e)
    {
        Error(e.what(), ast);
    }
}

/* --- Function declaration --- */

void GLSLGenerator::WriteFunction(FunctionDecl* ast)
{
    /* Write function header */
    if (auto structDecl = ast->returnType->structDecl.get())
    {
        Visit(ast->returnType);
        Blank();
        BeginLn();
        Write(structDecl->ident + " " + ast->FinalIdent() + "(");
    }
    else
    {
        BeginLn();
        Visit(ast->returnType);
        Write(" " + ast->FinalIdent() + "(");
    }

    /* Write parameters */
    for (std::size_t i = 0; i < ast->parameters.size(); ++i)
    {
        WriteParameter(ast->parameters[i].get());
        if (i + 1 < ast->parameters.size())
            Write(", ");
    }

    Write(")");

    if (ast->codeBlock)
    {
        /* Write function body */
        Visit(ast->codeBlock);
    }
    else
    {
        /* This is only a function forward declaration, so finish with statement terminator */
        Write(";");
        EndLn();
    }
}

void GLSLGenerator::WriteFunctionEntryPoint(FunctionDecl* ast)
{
    if (ast->IsForwardDecl())
        return;

    /* Write function header */
    BeginLn();
    Write("void main()");

    /* Write function body */
    WriteScopeOpen();
    {
        if (IsTessControlShader())
        {
            //TODO:
            // THIS IS INCOMPLETE!!!
            // more work is to do, to translate the patch constant function to GLSL!)
            if (auto patchConstFunc = GetProgram()->layoutTessControl.patchConstFunctionRef)
            {
                /* Call patch constant function inside main entry point only for the first invocation */
                WriteLn("if (gl_InvocationID == 0)");
                IncIndent();
                {
                    WriteLn(patchConstFunc->ident + "();");
                }
                DecIndent();
                Blank();
            }
        }

        WriteFunctionEntryPointBody(ast);
    }
    WriteScopeClose();
}

void GLSLGenerator::WriteFunctionEntryPointBody(FunctionDecl* ast)
{
    /* Write input/output parameters of system values as local variables */
    WriteLocalInputSemantics(ast);
    WriteLocalOutputSemantics(ast);

    /* Write code block (without additional scope) */
    WriteStmntList(ast->codeBlock->stmnts);

    /* Is the last statement a return statement? (ignore if the function has a non-void return type) */
    if ( ast->HasVoidReturnType() && ( ast->codeBlock->stmnts.empty() || ast->codeBlock->stmnts.back()->Type() != AST::Types::ReturnStmnt ) )
    {
        /* Write output semantic at the end of the code block, if no return statement was written before */
        WriteOutputSemanticsAssignment(nullptr);
    }
}

void GLSLGenerator::WriteFunctionSecondaryEntryPoint(FunctionDecl* ast)
{
    if (ast->IsForwardDecl())
        return;

    /* Write function header */
    BeginLn();
    Write("void " + ast->FinalIdent() + "()");

    /* Write function body */
    WriteScopeOpen();
    {
        WriteFunctionEntryPointBody(ast);
    }
    WriteScopeClose();
}

/* --- Function call --- */

void GLSLGenerator::AssertIntrinsicNumArgs(FunctionCall* ast, std::size_t numArgsMin, std::size_t numArgsMax)
{
    auto numArgs = ast->arguments.size();
    if (numArgs < numArgsMin || numArgs > numArgsMax)
        Error("invalid number of arguments for intrinsic", ast);
}

void GLSLGenerator::WriteFunctionCallStandard(FunctionCall* ast)
{
    /* Write function name */
    if (ast->varIdent)
    {
        if (ast->intrinsic != Intrinsic::Undefined && !IsWrappedIntrinsic(ast->intrinsic))
        {
            /* Write GLSL intrinsic keyword */
            auto keyword = IntrinsicToGLSLKeyword(ast->intrinsic);
            if (keyword)
                Write(*keyword);
            else
                Error("failed to map intrinsic '" + ast->varIdent->Last()->ToString() + "' to GLSL keyword", ast);
        }
        else
        {
            /* Write function identifier */
            Visit(ast->varIdent);
        }
    }
    else if (ast->typeDenoter)
    {
        /* Write type denoter */
        WriteTypeDenoter(*ast->typeDenoter, false, ast);
    }
    else
        Error("missing function name", ast);

    /* Write arguments */
    Write("(");

    for (std::size_t i = 0, n = ast->arguments.size(), m = n + ast->defaultArgumentRefs.size(); i < m; ++i)
    {
        if (i < n)
            Visit(ast->arguments[i]);
        else
            Visit(ast->defaultArgumentRefs[i - n]);

        if (i + 1 < m)
            Write(", ");
    }

    Write(")");
}

void GLSLGenerator::WriteFunctionCallIntrinsicMul(FunctionCall* ast)
{
    AssertIntrinsicNumArgs(ast, 2, 2);

    auto WriteMulArgument = [&](const ExprPtr& expr)
    {
        /*
        Determine if the expression needs extra brackets when converted from a function call "mul(lhs, rhs)" to a binary expression "lhs * rhs",
        e.g. "mul(wMatrix, pos + float4(0, 1, 0, 0))" -> "wMatrix * (pos + float4(0, 1, 0, 0))" needs extra brackets
        */
        auto type = expr->Type();
        if (type == AST::Types::TernaryExpr || type == AST::Types::BinaryExpr || type == AST::Types::UnaryExpr || type == AST::Types::PostUnaryExpr)
        {
            Write("(");
            Visit(expr);
            Write(")");
        }
        else
            Visit(expr);
    };

    /* Convert this function call into a multiplication */
    Write("(");
    {
        WriteMulArgument(ast->arguments[0]);
        Write(" * ");
        WriteMulArgument(ast->arguments[1]);
    }
    Write(")");
}

void GLSLGenerator::WriteFunctionCallIntrinsicRcp(FunctionCall* ast)
{
    AssertIntrinsicNumArgs(ast, 1, 1);

    /* Get type denoter of argument expression */
    auto& expr = ast->arguments.front();
    auto typeDenoter = expr->GetTypeDenoter()->Get();

    if (auto baseTypeDen = typeDenoter->As<BaseTypeDenoter>())
    {
        /* Convert this function call into a division */
        Write("(");
        {
            WriteTypeDenoter(*baseTypeDen, false, ast);
            Write("(");
            WriteLiteral("1", *baseTypeDen, ast);
            Write(") / (");
            Visit(expr);
        }
        Write("))");
    }
    else
        Error("invalid argument type for intrinsic 'rcp'", expr.get());
}

void GLSLGenerator::WriteFunctionCallIntrinsicClip(FunctionCall* ast)
{
    AssertIntrinsicNumArgs(ast, 1, 1);

    /* Get type denoter of argument expression */
    auto& expr = ast->arguments.front();
    auto typeDenoter = expr->GetTypeDenoter()->Get();

    if (auto baseTypeDen = typeDenoter->As<BaseTypeDenoter>())
    {
        /* Convert this function call into a condition */
        Write("if (");

        if (baseTypeDen->IsVector())
        {
            /* Convert to: 'any(lessThan(...))' */
            Write("any(lessThan(");

            auto binaryExpr = expr->As<BinaryExpr>();

            if (binaryExpr && binaryExpr->op == BinaryOp::Sub)
            {
                /* Convert to: 'any(lessThan(LHS-EXPR, RHS-EXPR))' */
                Visit(binaryExpr->lhsExpr);
                Write(", ");
                Visit(binaryExpr->rhsExpr);
            }
            else
            {
                /* Convert to: 'any(lessThan(EXPR, TYPE(0)))' */
                Visit(expr);
                Write(", ");
                WriteLiteral("0", *baseTypeDen, expr.get());
            }

            Write("))");
        }
        else if (baseTypeDen->IsScalar())
        {
            /* Convert to: 'EXPR < ...' */
            auto binaryExpr = expr->As<BinaryExpr>();

            if (binaryExpr && binaryExpr->op == BinaryOp::Sub)
            {
                /* Convert to: 'LHS-EXPR < RHS-EXPR' */
                Visit(binaryExpr->lhsExpr);
                Write(" < ");
                Visit(binaryExpr->rhsExpr);
            }
            else
            {
                /* Convert to: 'EXPR < TYPE(0)' */
                Visit(expr);
                Write(" < ");
                WriteLiteral("0", *baseTypeDen, expr.get());
            }
        }
        else
            Error("invalid argument type for intrinsic 'clip'", expr.get());
    }
    else
        Error("invalid argument type for intrinsic 'clip'", expr.get());

    Write(")");
    
    /* Write if-body (we are still inside an active line, so first 'EndLn', then 'BeginLn') */
    EndLn();
    IncIndent();
    BeginLn();
    Write("discard");
    DecIndent();
}

void GLSLGenerator::WriteFunctionCallIntrinsicAtomic(FunctionCall* ast)
{
    AssertIntrinsicNumArgs(ast, 2, 3);

    /* Find atomic intrinsic mapping */
    auto keyword = IntrinsicToGLSLKeyword(ast->intrinsic);
    if (keyword)
    {
        /* Write function call */
        if (ast->arguments.size() >= 3)
        {
            Visit(ast->arguments[2]);
            Write(" = ");
        }
        Write(*keyword + "(");
        Visit(ast->arguments[0]);
        Write(", ");
        Visit(ast->arguments[1]);
        Write(")");
    }
    else
        Error("failed to map intrinsic '" + ast->varIdent->ToString() + "' to GLSL keyword", ast);
}

/* --- Intrinsics wrapper functions --- */

void GLSLGenerator::WriteWrapperIntrinsics()
{
    auto program = GetProgram();

    if (auto usage = program->FetchIntrinsicUsage(Intrinsic::Clip))
        WriteWrapperIntrinsicsClip(*usage);
    if (auto usage = program->FetchIntrinsicUsage(Intrinsic::SinCos))
        WriteWrapperIntrinsicsSinCos(*usage);
}

void GLSLGenerator::WriteWrapperIntrinsicsClip(const IntrinsicUsage& usage)
{
    bool wrappersWritten = false;

    for (const auto& argList : usage.argLists)
    {
        auto arg0Type = (!argList.argTypes.empty() ? argList.argTypes.front() : DataType::Undefined);
        
        if (IsScalarType(arg0Type) || IsVectorType(arg0Type))
        {
            BeginLn();
            {
                /* Write function signature */
                Write("void clip(");
                WriteDataType(arg0Type, IsESSL());
                Write(" x)");

                /* Write function body */
                WriteScopeOpen(compactWrappers_);
                {
                    Write("if (");

                    if (IsScalarType(arg0Type))
                    {
                        Write("x < ");
                        WriteLiteral("0", arg0Type);
                    }
                    else if (IsVectorType(arg0Type))
                    {
                        Write("any(lessThan(x, ");
                        WriteDataType(arg0Type);
                        Write("(0)))");
                    }

                    Write(")");
                    WriteScopeOpen(compactWrappers_);
                    {
                        Write("discard;");
                    }
                    WriteScopeClose();
                }
                WriteScopeClose();
            }
            EndLn();

            wrappersWritten = true;
        }
    }

    if (wrappersWritten)
        Blank();
}

void GLSLGenerator::WriteWrapperIntrinsicsSinCos(const IntrinsicUsage& usage)
{
    bool wrappersWritten = false;

    for (const auto& argList : usage.argLists)
    {
        if (argList.argTypes.size() == 3)
        {
            BeginLn();
            {
                /* Write function signature */
                Write("void sincos(");
                WriteDataType(argList.argTypes[0], IsESSL());
                Write(" x, out ");
                WriteDataType(argList.argTypes[1], IsESSL());
                Write(" s, out ");
                WriteDataType(argList.argTypes[2], IsESSL());
                Write(" c)");

                /* Write function body */
                WriteScopeOpen(compactWrappers_);
                {
                    Write("s = sin(x), c = cos(x);");
                }
                WriteScopeClose();
            }
            EndLn();

            wrappersWritten = true;
        }
    }

    if (wrappersWritten)
        Blank();
}

/* --- Structure --- */

bool GLSLGenerator::WriteStructDecl(StructDecl* ast, bool writeSemicolon, bool allowNestedStruct)
{
    /* Is this a non-nested structure or are nested structures allowed in the current context? */
    if (!ast->flags(StructDecl::isNestedStruct) || allowNestedStruct)
    {
        //TODO: remove interface blocks
        #if 0
        /* Is this an interface block or a standard structure? */
        if (ast->flags(StructDecl::isShaderInput) || ast->flags(StructDecl::isShaderOutput))
        {
            /* Write structure as shader input/output block */
            return WriteStructDeclInputOutputBlock(ast);
        }
        else
        #endif
        {
            /* Write standard structure declaration */
            return WriteStructDeclStandard(ast, writeSemicolon);
        }
    }
    else if (!writeSemicolon)
    {
        /* Do not end line here with "EndLn" */
        BeginLn();
        Write(ast->ident + " ");
    }
    return false;
}

bool GLSLGenerator::WriteStructDeclStandard(StructDecl* ast, bool endWithSemicolon)
{
    /* Write structure signature */
    BeginLn();

    Write("struct");
    if (!ast->ident.empty())
        Write(' ' + ast->ident);

    /* Write structure members */
    WriteScopeOpen(false, endWithSemicolon);
    BeginSep();
    {
        WriteStructDeclMembers(ast);
    }
    EndSep();
    WriteScopeClose();

    return true;
}

bool GLSLGenerator::WriteStructDeclInputOutputBlock(StructDecl* ast)
{
    /* Only write input/output block if there is a non-system-value member */
    if (!ast->HasNonSystemValueMembers())
        return false;
    
    /* Write this structure as interface block (if structure doesn't need to be resolved) */
    BeginLn();
    
    if (ast->flags(StructDecl::isShaderInput))
        Write("in ");
    else
        Write("out ");
    Write(ast->ident);

    WriteScopeOpen();
    BeginSep();
    {
        isInsideInterfaceBlock_ = true;
        {
            WriteStructDeclMembers(ast);
        }
        isInsideInterfaceBlock_ = false;
    }
    EndSep();
    WriteScopeClose();

    WriteLn(ast->aliasName + ";");

    return true;
}

void GLSLGenerator::WriteStructDeclMembers(StructDecl* ast)
{
    if (ast->baseStructRef)
        WriteStructDeclMembers(ast->baseStructRef);
    Visit(ast->members);
}

/* --- BufferDecl --- */

void GLSLGenerator::WriteBufferDecl(BufferDecl* ast)
{
    if (ast->flags(AST::isReachable))
    {
        if (IsTextureBufferType(ast->GetBufferType()))
            WriteBufferDeclTexture(ast);
        else
            WriteBufferDeclStorageBuffer(ast);
        Blank();
    }
}

void GLSLGenerator::WriteBufferDeclTexture(BufferDecl* ast)
{
    /* Determine GLSL sampler type (or VKSL texture type) */
    auto bufferTypeKeyword = BufferTypeToKeyword(ast->GetBufferType(), ast->declStmntRef);
    if (!bufferTypeKeyword)
        return;

    BeginLn();
    {
        /* Write uniform declaration */
        if (explicitBinding_)
        {
            if (auto slotRegister = Register::GetForTarget(ast->slotRegisters, GetShaderTarget()))
                Write("layout(binding = " + std::to_string(slotRegister->slot) + ") ");
        }

        Write("uniform ");

        /* Write sampler type and identifier */
        if (auto genericTypeDen = ast->declStmntRef->typeDenoter->genericTypeDenoter)
        {
            if (auto baseTypeDen = genericTypeDen->As<BaseTypeDenoter>())
            {
                if (IsIntType(baseTypeDen->dataType))
                    Write("i");
                else if (IsUIntType(baseTypeDen->dataType))
                    Write("u");
            }
        }

        Write(*bufferTypeKeyword + " " + ast->ident + ";");
    }
    EndLn();
}

void GLSLGenerator::WriteBufferDeclStorageBuffer(BufferDecl* ast)
{
    /* Determine GLSL buffer type */
    auto bufferTypeKeyword = BufferTypeToKeyword(ast->GetBufferType(), ast->declStmntRef);
    if (!bufferTypeKeyword)
        return;

    /* Write buffer declaration */
    BeginLn();
    {
        Write("layout(std430");

        if (explicitBinding_)
        {
            if (auto slotRegister = Register::GetForTarget(ast->slotRegisters, GetShaderTarget()))
                Write(", binding = " + std::to_string(slotRegister->slot));
        }

        Write(") " + *bufferTypeKeyword + " " + nameManglingPrefix_ + ast->ident);
    }
    EndLn();

    /* Write buffer array (of variable size) */
    WriteScopeOpen(false, true);
    {
        BeginLn();
        {
            /* Write optional memory type qualifier */
            if (!IsRWBufferType(ast->GetBufferType()))
                Write("readonly ");

            /* Write generic type denoterand identifier */
            auto genericTypeDen = ast->declStmntRef->typeDenoter->GetGenericTypeDenoter();
            WriteTypeDenoter(*genericTypeDen, IsESSL(), ast);
            Write(" " + ast->ident + "[];");
        }
        EndLn();
    }
    WriteScopeClose();
}

/* --- Misc --- */

void GLSLGenerator::WriteStmntComment(Stmnt* ast, bool insertBlank)
{
    if (ast && !ast->comment.empty())
    {
        if (insertBlank)
            Blank();
        WriteComment(ast->comment);
    }
}

void GLSLGenerator::WriteStmntList(const std::vector<StmntPtr>& stmnts, bool isGlobalScope)
{
    if (preserveComments_)
    {
        /* Write statements with optional commentaries */
        for (std::size_t i = 0; i < stmnts.size(); ++i)
        {
            auto ast = stmnts[i].get();

            if (!isGlobalScope || ast->flags(AST::isReachable))
                WriteStmntComment(ast, (!isGlobalScope && (i > 0)));

            Visit(ast);
        }
    }
    else
    {
        /* Write statements only */
        Visit(stmnts);
    }
}

void GLSLGenerator::WriteParameter(VarDeclStmnt* ast)
{
    /* Write input modifier */
    if (ast->IsOutput())
    {
        if (ast->IsInput())
            Write("inout ");
        else
            Write("out ");
    }

    /* Write type modifiers */
    WriteTypeModifiers(ast->typeModifiers, ast->varType->GetTypeDenoter()->Get());

    /* Write parameter type */
    Visit(ast->varType);
    Write(" ");

    /* Write parameter identifier (without default initializer) */
    if (ast->varDecls.size() == 1)
    {
        auto paramVar = ast->varDecls.front().get();
        Write(paramVar->FinalIdent());
        Visit(paramVar->arrayDims);
    }
    else
        Error("invalid number of variables in function parameter", ast);
}

void GLSLGenerator::WriteScopedStmnt(Stmnt* ast)
{
    if (ast)
    {
        if (ast->Type() != AST::Types::CodeBlockStmnt)
        {
            WriteScopeOpen(false, false, alwaysBracedScopes_);
            {
                Visit(ast);
            }
            WriteScopeClose();
        }
        else
            Visit(ast);
    }
}

void GLSLGenerator::WriteArrayIndices(const std::vector<ExprPtr>& arrayDims)
{
    for (auto& dim : arrayDims)
    {
        Write("[");
        Visit(dim);
        Write("]");
    }
}

void GLSLGenerator::WriteLiteral(const std::string& value, const BaseTypeDenoter& baseTypeDen, const AST* ast)
{
    if (baseTypeDen.IsScalar())
    {
        Write(value);

        switch (baseTypeDen.dataType)
        {
            case DataType::UInt:
                Write("u");
                break;
            case DataType::Float:
                if (value.find_first_of(".eE") == std::string::npos)
                    Write(".0");
                Write("f");
                break;
            default:
                break;
        }
    }
    else if (baseTypeDen.IsVector())
    {
        WriteDataType(baseTypeDen.dataType, false, ast);
        Write("(");
        Write(value);
        Write(")");
    }
    else
        Error("failed to write type denoter for literal '" + value + "'", ast);
}


} // /namespace Xsc



// ================================================================================
